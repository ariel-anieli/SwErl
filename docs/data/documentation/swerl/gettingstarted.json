{"metadata":{"title":"GettingStarted","modules":[{"name":"SwErl"}],"roleHeading":"Article","role":"article"},"sections":[],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/SwErl\/documentation\/SwErl\/GettingStarted"},"primaryContentSections":[{"content":[{"type":"heading","level":2,"anchor":"Overview","text":"Overview"},{"inlineContent":[{"type":"text","text":"Most SwErl apps will contain hundreds of independent processes communicating with messages. This will show you how to spawn and message processes, and teach you the basics of how to design and build apps built on processes."}],"type":"paragraph"},{"type":"heading","level":2,"anchor":"Processes","text":"Processes"},{"inlineContent":[{"type":"text","text":"To spawn most SwErl processes, we simply provide "},{"code":"spawn()","type":"codeVoice"},{"type":"text","text":" a closure. Any time a message is sent to that process, the closure will execute. These closures must have two arguments. The first is the PID of the process associated with the closure, the second is the message provided by the caller. No need to worry about providing "},{"code":"pid","type":"codeVoice"},{"type":"text","text":", SwErl does that automatically."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Once you have a process you pass it messages with the send operator: "},{"code":"!","type":"codeVoice"},{"type":"text","text":" ."}],"type":"paragraph"},{"inlineContent":[{"text":"Because messages can be any type, you will often need to cast message to expected types.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let myMessage = \"Some message, any type is fine!\"","","let myProcess = try spawnsysf{(pid, message) in","\tswitch message {","\t\tcase let message as String :","\t\t\t\/\/ The below simply demonstrating that the message argument is what's on the","\t\t\t\/\/ RHS of the send operator. This assert throws if you pass in a","\t\t\t\/\/ different message.","\t\t\tassert(message == myMessage, \"Did you pass in a different message?\")","\t\tdefault : ","\t\t\tbreak","\t}","}","myProcess ! myMessage"]},{"inlineContent":[{"type":"text","text":"Processes can also be registered with names, which can then be used instead of the pid variable as a string literal in source code. If you’re familiar with Erlang, these string literals are serving the roll of atoms."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["_ = try spawnsysf(name: \"my_process\"){(pid, message) in","    print(message)","}","","\"my_process\" ! \"Hi there.\""]},{"inlineContent":[{"type":"text","text":"Message passing like this is unidirectional. The caller does not wait for a response before continuing, and does not receive a promise or a handle or anything of the sort. Once a message is sent, it is completely in the domain of the callee. If you want to get a response to your message, you’ll have to provide a return address."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["\/\/ This example is quite contrived, your architecture will often look quite different.","","_ = try spawnsysf(name: \"replier\"){(pid, message) in","    switch message {","        case let (pid, str) as (Pid, String) :","            pid ! \"\\(procPid) received the following message: \\(str)\"","        case let str as String :","            print(\"no way to reply to message \\(str)\")","        default:","            break","    }","}","","_ = try spawnsysf(name: \"myProcess\"){(pid, message) in","    switch message {","        case let str as String:","            \/\/ BUG THIS IS NOT HOW TO PATTERN MATCH IN THIS LANGUAGE","            \/\/ MUST FIND HOW TO DO THIS WITHOUT NESTING","            if (str == \"start\") {","                \"replier\" ! (procPid, \"first message!\")","            } else {","                print(\"A response: \\(str)\")","            }","        default :","            break","    }","}","","\"myProcess\" ! \"start\""]},{"type":"heading","level":2,"anchor":"User-IO-with-SwErl","text":"User I\/O with SwErl"},{"inlineContent":[{"type":"text","text":"SwErl processes are implemented using the default system-selected global dispatch queue by default. You can easily create a process which runs on the main thread for IO operations, however:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let ioProcess = try spawnsysf(queueToUse: DispatchQueue.main){","\t(procPid, message) in ","\t\t\/\/ Do some UI things.","    }"]},{"inlineContent":[{"type":"text","text":"The same for any concurrency in swift applies here. The main thread should be reserved for only the highest priority operations, such as those affecting the user interface."}],"type":"paragraph"},{"type":"heading","level":2,"anchor":"OTP-Behaviors","text":"OTP Behaviors"},{"inlineContent":[{"type":"text","text":"Generally speaking, these primitives reflect the usage and design of their Erlang counterparts, though with only the most oft-used functionality implemented. If you are unfamiliar with Erlang\/OTP, you may find the "},{"identifier":"https:\/\/www.erlang.org\/doc\/design_principles\/des_princ","type":"reference","isActive":true},{"type":"text","text":" of interest."},{"type":"text","text":" "},{"type":"text","text":"Behaviors are implemented as protocols in SwErl. Behaviors are"}],"type":"paragraph"},{"type":"heading","level":3,"anchor":"GenServer","text":"GenServer"},{"inlineContent":[{"type":"text","text":"GenServers, or Generic Servers are independent processes which act as servers in a client\/server relationship. They have all the functionality of a normal SwErl process, including an internal state, with the added ability to accept and respond to synchronous requests via "},{"type":"codeVoice","code":"GenServer.call(...)"},{"type":"text","text":". Other processes making a Call to a genServer will hang expecting a response. genServers in SwErl all have a uniform API accessible via "},{"type":"codeVoice","code":"GenServer"},{"type":"text","text":". genServers are created by writing a static type conforming to "},{"type":"codeVoice","code":"protocol GenServerBehavior"},{"type":"text","text":" to establish the functionality of a genServer instance, then instantiated using"},{"type":"codeVoice","code":"GenServer.link()."}],"type":"paragraph"},{"inlineContent":[{"text":"To demonstrate, we will make an echo server.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["\/\/\/","\/\/\/ echo.swift","\/\/\/ Created by You, Today!","\/\/\/","","enum echoServer : GenServerBehavior {","\/\/GenServerBehavior enforces five hooks, shown below.","","\/\/initialize data is called once on startup. Our simple echo server does not maintain any state, so we will simply leave any argument data as is.","static func initializeData(_ data: Any?) -> Any? {","\treturn data","}","","\/\/terminateCleanup is called once on termination, and would generally be used to clean up any messy resources Swift would be unable to automatically garbage collect. Our server has no such held resources.","static func terminateCleanup(reason: String, data: Any?) {","","}","","\/\/handleCast is called whenever the server receives a message from another process via GenServer.call() and returns a tuple. the first item in the tuple is the response to the caller, the second is the updated state of the genServer, called data.","\/\/Our echo server will reply with whatever request it receives.","static func handleCall(request: Any, data: Any?) -> (Any,Any) {","\treturn (request, data)","}","","\/\/handleCast is called whenever the server receives a message from another process via GenServer.cast(). Casts are asynchronous messages, the caster cannot receive any reply. the return value is the updated state of the genServer.","","\/\/ Our echo server is not expecting any such messages, certainly not any that would mutate it's state. In response to a cast, we will do nothing.","static func handleCast(request: Any, data: Any?) -> Any? {","\treturn data","}",""]},{"inlineContent":[{"type":"text","text":"Now we register a gen server with these functions, and make a call!"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["GenServer.startlink(\"echo\", [])","print(GenServer.call(echo, \"hello SwErl!\"))"]},{"syntax":null,"type":"codeListing","code":["hello SwErl!"]},{"inlineContent":[{"text":"Multiple different genServers can be initialized from the same behavior. SwErl ensures multiple local servers cannot share the same name, and automatically ensures unique pids.","type":"text"}],"type":"paragraph"},{"type":"heading","level":3,"anchor":"Gen-StateM","text":"Gen StateM"},{"inlineContent":[{"type":"text","text":"Event-driven Generic State Machine. Briefly paraphrasing "},{"isActive":true,"identifier":"https:\/\/www.erlang.org\/doc\/design_principles\/statem","type":"reference"},{"type":"text","text":", Event-driven state machines wait for inputs, trigger some action(s) based on its current state and input, then trigger a state transition. Unlike a Gen server, a state machine’s state is not arbitrary. state machines have a finite set of programmer defined states and pre-defined transitions between states. The Erlang design documentation provides several good heuristics for when a GenStateM should be used over a GenServer, one more is provided here: When the allowed functionality of a module varies dramatically depending on previous events."},{"type":"text","text":" "},{"type":"text","text":"genServer. By way of example, an ATM can be effectively modeled as a state machine with two states. Of course, this example glosses over many security features the machine would need and is presented only for demonstrating the features of SwErl and Erlang."}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"StateMDesign"}],"type":"paragraph"},{"inlineContent":[{"text":"If such a state machine were to receive a request to dispense cash when in idle state, the request would fail.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Note that the current implementation of SwErl GenStateM lack many of the specialized features found in Erlang’s gen_statem module. Presently, they have the same functionality as GenServers."}],"type":"paragraph"},{"type":"heading","level":3,"anchor":"Gen-Event","text":"Gen Event"},{"inlineContent":[{"type":"text","text":"The Gen Event module has two distinct pieces. Event Managers and Event Handlers. Event Managers generally represent a single event. Event Handlers are actions taken as a result of that event. In Erlang, event Handlers are fully-fledged processes with an internal state and additional hooks.  Presently in SwErl Event Handlers are simply functions."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Event Handlers must have two parameters. The first is the PID of the event Manager they are attached to, the second is the "},{"type":"codeVoice","code":"message"},{"type":"text","text":" supplied in the notification."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Multiple Event handlers can be attached to one Event Manager. Whenever an Event Manager receives a notification via "},{"type":"codeVoice","code":"EventManager.notify(name OR pid, message)"},{"type":"text","text":", it calls each attached Event Handler in sequence."}],"type":"paragraph"}],"kind":"content"}],"hierarchy":{"paths":[["doc:\/\/SwErl\/documentation\/SwErl"]]},"schemaVersion":{"minor":3,"major":0,"patch":0},"kind":"article","variants":[{"paths":["\/documentation\/swerl\/gettingstarted"],"traits":[{"interfaceLanguage":"swift"}]}],"abstract":[{"type":"text","text":"The most important features of SwErl"}],"references":{"https://www.erlang.org/doc/design_principles/statem":{"titleInlineContent":[{"text":"the erlang design documentation","type":"text"}],"identifier":"https:\/\/www.erlang.org\/doc\/design_principles\/statem","type":"link","title":"the erlang design documentation","url":"https:\/\/www.erlang.org\/doc\/design_principles\/statem"},"https://www.erlang.org/doc/design_principles/des_princ":{"titleInlineContent":[{"text":"Erlang OTP Design Principles Documentation","type":"text"}],"identifier":"https:\/\/www.erlang.org\/doc\/design_principles\/des_princ","type":"link","title":"Erlang OTP Design Principles Documentation","url":"https:\/\/www.erlang.org\/doc\/design_principles\/des_princ"},"doc://SwErl/documentation/SwErl":{"identifier":"doc:\/\/SwErl\/documentation\/SwErl","type":"topic","title":"SwErl","abstract":[{"text":"Concurrency - Erlang style","type":"text"}],"kind":"symbol","url":"\/documentation\/swerl","role":"collection"},"StateMDesign":{"variants":[{"url":"\/images\/StateMDesign.png","traits":["1x","light"]}],"identifier":"StateMDesign","alt":"a simple ATM modeled as a state machine","type":"image"}}}